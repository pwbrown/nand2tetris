/**
 * Jack OS : Memory
 * Author  : Philip Brown
 * Source  : https://github.com/pwbrown/nand2tetris/n2t/os/Memory.jack
 * 
 * My implementation of the Jack OS Memory class for Nand2Tetris project 12
 */

class Memory {
    static Array ramBase, freeList;

    /**
     * Initialize the Memory class' static values
     */
    function void init() {
        var int dataMemorySize, heapBase, heapSize;
        
        // Fill in base addresses for memory and heap (freeList)
        let ramBase = 0; // Sets the base address of the entire ram
        let dataMemorySize = 16384; // Number of words addressable for data
        let heapBase = 2048;
        
        // Set the current pointer for the freeList to the start of the heap
        let freeList = heapBase;
        
        // Set the next segment and block sizes
        let heapSize = dataMemorySize - heapBase; // 16384 is the size of the first RAM16K chip before the screen memory map
        let freeList[0] = null;
        let freeList[1] = heapSize - 2; // Block size excludes the overhead values

        return;
    }

    /**
     * Peek at a value in memory
     */
    function int peek(int address) {
        return ramBase[address];
    }

    /**
     * Poke/set a value in memory at the given address
     */
    function void poke(int address, int value) {
        let ramBase[address] = value;
        return;
    }

    /**
     * Searches for a block within the free list to allocate
     */
    function Array alloc(int size) {
        var Array prev, curr, next;
        var int allocSize, currSize;

        // Make sure that the free list is not empty
        if (freeList = null) {
            do Sys.error(5);
            return 0;
        }

        let allocSize = size + 2; // Includes overhead

        let prev = null;
        let curr = freeList;

        // Locate the first (first fit) available segment that is large enough
        while (true) {
            let currSize = curr[1];
            // Check if the current segment is exactly the right size with or without overhead
            // size <= currSize <= allocSize
            // this means that a reused segment can have up to 2 unused words, but I'm fine with that
            if ((~(currSize < size)) & (~(currSize > allocSize))) {
                let next = curr[0];
                // Attempt to point the previous segment at the next segment
                if ((~(prev = null)) & (~(next = null))) {
                    prev[0] = next;
                }
                // Move the free list to the start of the next segment if the current was the start of the free list
                if (prev = null) {
                    freeList = next;
                }
                // Nullify the segment pointer (no need to set size since it's already correct)
                let curr[0] = null;
                return curr + 2;
            }
            // Check if the current segment is large enough to allocate
            if (currSize > allocSize) {
                // Slice off a block from the end of the segment
                let currSize = currSize - allocSize;
                let curr[1] = currSize;
                // Move the segment to the new allocated space and set overhead
                let curr = curr + 2 + currSize;
                let curr[0] = null;
                let curr[1] = size;
                // Return the base address of the allocated segment's block
                return curr + 2;
            }
            // Increment to the next segment
            let prev = curr;
            let curr = curr[0];
            if (curr = null) {
                do Sys.error(5);
                return 0;
            }
        }
    }

    /**
     * Deallocates an object from memory
     */
    function void deAlloc(Array obj) {
        var Array objSegment, curr, next;

        let objSegment = obj - 2; // move to beginning of segment (overhead)
        let curr = freeList;
        let next = curr[0];

        // Go all the way to the last item (TODO: insert in memory order to implement defrag)
        while (~(next = null)) {
            let curr = next;
            let next = curr[0];
        }

        // Append object segment to the end of the free list
        let objSegment[0] = null;
        let curr[0] = objSegment;

        return;
    }
}
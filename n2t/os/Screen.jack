/**
 * Jack OS : Screen
 * Author  : Philip Brown
 * Source  : https://github.com/pwbrown/nand2tetris/n2t/os/Screen.jack
 * 
 * My implementation of the Jack OS Screen class for Nand2Tetris project 12
 * 
 * To avoid additional function calls and therefore additional VM and assembly lines,
 * I decided to replace Memory.poke and Memory.peek calls with simple direct memory
 * access using the base screen address. This implementation also has safeguards in place
 * to prevent writing to memory outside of the screen map. This implementation also prevents
 * all forms of screen overflow.
 */

class Screen {
    static Array screen, bits;
    static int width, height, wordSize, rowWords, maxX, maxY;
    static boolean color;

    /**
     * Initialize screen static variables
     */
    function void init() {
        var int i, mask;

        /** Set the screen base address */
        let screen = 16384;

        /** Set screen dimensions in pixels */
        let width = 512;
        let height = 256;

        /** Set word size and row word count */
        let wordSize = 16;
        let rowWords = width / wordSize;

        /** Maximum index values */
        let maxX = width - 1;
        let maxY = height - 1;

        /** Initialize color */
        let color = false;

        /** Create a precomputed array of bit mask values (same as Math.jack) */
        let i = 0;
        let bits = Array.new(wordSize);
        let mask = 1;
        while (i < wordSize) {
            let bits[i] = mask;
            let mask = mask + mask;
            let i = i + 1;
        }
        return;
    }

    /**
     * Clear the entire screen
     */
    function void clearScreen() {
        var int i, end;
        let i = 0;
        let end = (height * rowWords) + 1;
        while (i < end) {
            let screen[i] = 0;
            let i = i + 1;
        }
        return;
    }

    /**
     * Sets the color attribute
     */
    function void setColor(boolean b) {
        let color = b;
        return;
    }

    /**
     * Draw a single pixel on the screen
     */
    function void drawPixel(int x, int y) {
        /** Ignore pixel overflow */
        if ((x < 0) | (x > maxX) | (y < 0) | (y > maxY)) {
            return;
        }
        do Screen.drawIndexMask(
            (rowWords * y) + (x / wordSize),
            bits[x - (wordSize * (x / wordSize))] // bits[x % wordSize]
        );
        return;
    }

    /**
     * Draw one or more pixels given a pre-computed
     * screen address index and mask value
     */
    function void drawIndexMask(int i, int mask) {
        var int value;
        /**
         * Using a value variable to store current value and reduce
         * index expression calls which require more stack operations
         */
        let value = screen[i];
        if (color) {
            let value = value | mask;
        } else {
            let value = value & ~mask;
        }
        let screen[i] = value;
        return;
    }

    /**
     * Draw a line on the screen
     */
    function void drawLine(int x1, int y1, int x2, int y2) {
        // Single pixel
        if ((x1 = x2) & (y1 = y2)) {
            do Screen.drawPixel(x1, y1);
            return;
        }
        // Vertical Line
        if (x1 = x2) {
            do Screen.drawVerticalLine(x1, y1, y2);
            return;
        }
        // Horizontal Line
        if (y1 = y2) {
            do Screen.drawHorizontalLine(x1, x2, y1);
            return;
        }
        // Diagonal Line
        do Screen.drawDiagonalLine(x1, y1, x2, y2);
        return;
    }

    /**
     * Draw a vertical line (series of single pixel draw operations)
     */
    function void drawVerticalLine(int x, int y1, int y2) {
        var int i, mask;

        /** Ignore out-of-bounds x coordinate */
        if ((x < 0) | (x > maxX)) {
            return;
        }

        /** Swap y values to make sure we draw top down */
        if (y2 < y1) {
            let mask = y1; // reuse mask as a swap temp variable
            let y1 = y2;
            let y2 = mask;
        }

        /** Discard out-of-bound y coordinates */
        if (y1 < 0) {
            let y1 = 0;
        }
        if (y2 > maxY) {
            let y2 = maxY;
        }

        /** Set base index and static mask value */
        let i = (x / wordSize) + (rowWords * y1);
        let mask = bits[x - (wordSize * (x / wordSize))];

        /** Start drawing from top to bottom */
        while (~(y1 > y2)) {
            do Screen.drawIndexMask(i, mask);
            let y1 = y1 + 1; // Increment to a row down
            let i = i + rowWords; // Update the index to the next row
        }
        return;
    }

    /**
     * Draw a horizontal line (series of either partial or full address drawings)
     */
    function void drawHorizontalLine(int x1, int x2, int y) {
        var int curr, start, end, mask, currBit, endBit;

        /** Ignore overflow y coordinates */
        if ((y < 0) | (y > maxY)) {
            return;
        }

        /** Swap x values to ensure drawing from left to right */
        if (x2 < x1) {
            let mask = x1; // reuse mask as swap temp variable
            let x1 = x2;
            let x2 = mask;
        }

        /** Discard out-of-bound x coordinates */
        if (x1 < 0) {
            let x1 = 0;
        }
        if (x2 > maxX) {
            let x2 = maxX;
        }

        /** Set address indexes */
        let curr = rowWords * y; // reuse curr to set base index
        let start = curr + (x1 / wordSize);
        let end = curr + (x2 / wordSize);
        let curr = start;

        while (~(curr > end)) {
            if ((curr > start) & (curr < end)) {
                /** Selects the entire index for drawing */
                let mask = -1;
            } else {
                /** Selects a subset of address bits for drawing */
                let mask = 0;
                /** Set current and end bit indexes */
                let currBit = 0;
                let endBit = wordSize - 1;
                if (curr = start) {
                    let currBit = x1 - (wordSize * (x1 / wordSize)); // x1 % wordSize
                }
                if (curr = end) {
                    let endBit = x2 - (wordSize * (x2 / wordSize)); // x2 % wordSize
                }
                /** Calculate bit mask as sum of all bit values between the start and end bit indexes */
                while (~(currBit > endBit)) {
                    let mask = mask + bits[currBit];
                    let currBit = currBit + 1;
                }
            }
            do Screen.drawIndexMask(curr, mask);
            let curr = curr + 1;
        }
        return;
    }

    /**
     * Draw a diagonal line
     */
    function void drawDiagonalLine(int x1, int y1, int x2, int y2) {
        var int dx, dy, a, b, yInc, diff;

        /** Swap coordinates to ensure that we always move from left to right */
        if (x2 < x1) {
            let diff = x1;
            let x1 = x2;
            let x2 = diff;
            let diff = y1;
            let y1 = y2;
            let y2 = diff;
        }

        /** Setup helper variables */
        let dx = x2 - x1;
        let dy = y2 - y1;
        let yInc = 1;
        if (dy < 0) {
            let yInc = -1;
        }

        let diff = 0;
        while ((~(a > dx)) & (((yInc = 1) & ~(b > dy)) | ((yInc = -1) & ~(b < dy)))) {
            do Screen.drawPixel(x1 + a, y1 + b);
            if (diff < 0) {
                let a = a + 1;
                let diff = diff + (dy * yInc);
            } else {
                let b = b + yInc;
                let diff = diff - dx;
            }
        }
        return;
    }

    /**
     * Draw a filled rectangle
     */
    function void drawRectangle(int x1, int y1, int x2, int y2) {
        var int temp;

        /** Swap coordinates to draw from top to bottom */
        if (y2 < y1) {
            let temp = y1;
            let y1 = y2;
            let y2 = temp;
            let temp = x1;
            let x1 = x2;
            let x2 = temp;
        }

        /** Draw a series of horizontal lines for the height of the rectangle */
        while (~(y1 > y2)) {
            do Screen.drawHorizontalLine(x1, x2, y1);
            let y1 = y1 + 1;
        }
        return;
    }

    /**
     * Draw a filled circle
     */
    function void drawCircle(int x, int y, int r) {
        var int xOffset, rSquared, i, xl, xr;

        /** Draw the center horizontal line */
        do Screen.drawHorizontalLine(x - r, x + r, y);

        /** Draw top and bottom halves */
        let i = 1;
        let rSquared = r * r;
        while (~(i > r)) {
            let xOffset = Math.sqrt(rSquared - (i * i));
            let xl = x - xOffset;
            let xr = x + xOffset;
            do Screen.drawHorizontalLine(xl, xr, y + i); // top half line
            do Screen.drawHorizontalLine(xl, xr, y - i); // bottom half line
            let i = i + 1;
        }

        return;
    }
}